# 授课内容 PA2.2
# 指令系统
上一节只完成了几个指令，剩下所有未完成的指令均需要完成（看讲义上要求的），本课目标是跑通所有`cputest`中所有的测试用例。
> AM是什么？英文：抽象机器
>
> AM为程序的运行提供运行时环境，它是直接跑在NEMU上的

NEMU模拟的是计算机硬件，但是程序不能直接跑在硬件上，需要运行时环境的支持。就像我们写个`helloworld`，其实需要操作系统的支持才能运行起来一样。AM又和OS不同，OS具有进程管理、文件管理等等诸多功能，而**AM只是在编译时将运行时环境编译进了程序**（先这样理解）

## AM的源文件组织
照PPT讲即可。我们目前只关心`nexus-am/am/arch/x86-nemu`即可，**通过AM来编译出能在NEMU下跑的程序**，其实我们之前的dummy就是通过AM进行的交叉编译。
> 提问：何为交叉编译？答案：在一个平台编译出在另一个平台上跑的程序。如各位曾经（或者现在也在）`Dev C++`用的`MinGW`，其全称`Minimalist GNU for Windows`，有兴趣可以网上查一下。

## 以dummy为例
大家可以看看通过AM编译出来的程序，在`cputest/build`里面，用`objdump`反汇编一下能看到AM在main函数之前加了什么。

注意：**AM和客户程序一起编译，而NEMU单独编译**。

## 用AM交叉编译的程序的执行过程
见`trm.c`文件。首先程序入口从`_start`开始，这个子过程只负责设置栈顶（该子过程直接由汇编语言编写），然后就跳转到`_trm_init`子过程`交给AM做初始化`，完毕后调用`main函数`，进入执行。
执行main函数（即用户程序部分），执行完毕后返回`_trm_init`，用`_halt()`结束执行。

## 要做的事情
1. 本节要做的事情是跑通`nexus-am/tests/cputest/tests`里面的**所有测试用例**。执行每个测试用例的方法和执行`dummy`一样：
``` bash
make ARCH=x86-nemu ALL=xxx run
```
> 嫌麻烦？讲义上说了，可以把`ARCH=x86-nemu`在`Makefile`里面进行修改。

2. 每个测试用例必然会包含没有实现的指令，然后报出那个红红的字符艺术字i386 Manual，然后依次实现指令就行了。每个测试用例通过的标准为：**`HIT GOOD TRAP`**
> 注意：部分算术运算指令框架已实现好，需要自行填写声明。

## 友情提醒&其他应注意的地方
> 我们学C语言的时候如何调试？答案：IDE的调试功能，或者用printf打印出来。但是这里我们无法给大家提供IDE简洁的调试功能（当然，你喜欢的话可以试试用`make gdb`来调试）

但是我们此处还没有实现往屏幕上输出一句话，不能在**用户程序**（注意是在用户程序）中调用`printf`等库函数。
但是**可以在写的指令函数中调用printf这些来显示中间值**等。
大家在实现的过程中需要**充分利用我们之前PA1里面做的扫描内存、打印寄存器、监视点、单步执行的调试器功能**

然后还可以利用一些提供的宏来帮助大家调试，比如`nemu_assert(条件)`，具体如：
``` c
int i = 5;
nemu_assert(i==5)
```
如果`i`不等于`5`，NEMU将终止运行。

注意：**应按照讲义上给的顺序进行测试**，即先其他所有用例，然后`string`用例，最后`hello-str`用例

# 基础设施（2）
这部分PPT没有，请各位务必仔细看讲义和本Talk

我们在PA1中做过一些最简单的基础设施，模拟GDB功能，现在我们需要直接测试写的指令对不对，所以我们引入了：**Differential Testing**（对比测试）。

该模块的原理和功能为：**同时在NEMU和QEMU中跑用户程序，然后每一步后对比这一条指令跑得是否一样，以此来检测你的指令实现的是否有错**。

具体怎么引入看讲义，写的很详细，**请务必按照讲义上面说的一步一步来，一个细节都不能放过，真的讲义说的已经不能更加详细了**，我们这边只会说一些实践上的方法。

## 要做的事情
1. 引入`Differential Testing机制`
2. 实现`Differential Testing`

### 在哪实现？
需要写的函数位于文件`ics2017\nemu\src\monitor\diff-test\diff-test.c`中

### 实现什么？
在`difftest_step()`函数中添加相应的代码，实现我们所说的对比测试。

### 如何实现？
提示：一共需要在`difftest_step()`函数中添加**至少20行代码就能解决这个问题**。非常简单。
我们只需要将该函数中的`r`变量和**我们自己的模拟CPU中的8个通用寄存器进行逐一比较即可**。是不是非常简单。那么问题来了：我怎么知道`r`里面的寄存器怎么访问呢？请阅读代码看看`gdb_regs`这个联合体的结构吧！

### 实现后做什么？
当然这个见仁见智。你只需单纯地输出`r`中的和你自己`cpu`中的寄存器，并将其相对比，当对比发现有寄存器值不同的时候报错并停止项目运行，以便你修复错误，当然，对比检查会拖慢NEMU的运行，你不需要时时刻刻都运行它，仅在对比检查的时候运行即可。

# 一键回归测试
## 要做的事情
顾名思义，**你需要将所有的测试用例通过检查**，才能代表所有指令的实现在现阶段没有明显错误（但不代表一定没有隐藏错误，所以要**保证没有隐藏错误的关键在于严格按照i386手册实现每一条指令**）

# 别忘了回答思考题





